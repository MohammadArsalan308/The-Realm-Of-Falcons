from falcon import bcolors
solution_list=[]
solution_xss=[]
solution_sql=[]
rs_vul_list = list()

# Classifies the Vulnerability's Severity
def vul_info(val):
    result =''
    if val == 'c':
        result = " critical "
    elif val == 'h':
        result =" high "
    elif val == 'm':
        result = " medium "
    elif val == 'l':
        result = " low "
    else:
        result =" info "
    return result


# Links the vulnerability with threat level and remediation database
def vul_remed_info(v1,v2,v3):

    print(bcolors.BOLD+"\nVulnerability Threat Level"+bcolors.RESET)
    print("\t"+vul_info(v2)+" "+bcolors.WARNING+str(vuln_resp[v1][0])+bcolors.RESET)
    print(bcolors.BOLD+"Vulnerability Definition"+bcolors.RESET)
    print("\t"+bcolors.OKPURPLE+str(vuln_fix[v3-1][1])+bcolors.RESET)
    print(bcolors.BOLD+"Vulnerability Remediation"+bcolors.RESET)
    print("\t"+bcolors.OKGREEN+str(vuln_fix[v3-1][2])+bcolors.RESET)
    b=str(vuln_fix[v3-1][1])
    a=str(vul_info(v2))+" "+str(vuln_resp[v1][0]) 
    c=str(vuln_fix[v3-1][2])
    return a,b,c

# Tool Responses (Begins) [Responses + Severity (c - critical | h - high | m - medium | l - low | i - informational) + Reference for Vuln Definition and Remediation]
vuln_resp   = [
                #1
                ["Vulnerable to reflected Cross-Site Scripting attacks.","m",1],

                #2
                ["SQL-injection vulnerability detected on the URL itself (In-Band SQLi).","m",2],

                #3
                ["Vulnerable to SQL-injection","m",3],

                #4
                ["Some ports are open.","l",4],

                #5
                ["Open files/directories found.","i",5],

                #6
                ["Found sub-domains.","l",6]

            ]

# Vulnerabilities and Remediation
vuln_fix = [
                    [1, "Cross-Site Scripting (XSS) is classified as an injection attack where malicious JavaScript gets injected into a web application with the intention of being executed by other users. A web application is vulnerable to XSS if it uses unsanitized user input.",
                            "Filter input on arrival: At the point where user input is received, filter as strictly as possible based on what is expected or valid input.\n\tEncode data on output: At the point where user-controllable data is output in HTTP responses, encode the output to prevent it from being interpreted as active content. Depending on the output context, this might require applying combinations of HTML, URL, JavaScript, and CSS encoding.\n\tUse appropriate response headers: To prevent XSS in HTTP responses that aren't intended to contain any HTML or JavaScript, you can use the Content-Type and X-Content-Type-Options headers to ensure that browsers interpret the responses in the way you intend.\n\tContent Security Policy: As a last line of defense, you can use Content Security Policy (CSP) to reduce the severity of any XSS vulnerabilities that still occur."],

                    [2, "SQL Injection (SQLi) occurs when user controlled input is passed to SQL queries. As a result, an attacker can pass in SQL queries to manipulate the outcome of such queries. A successful SQL injection attack can result in unauthorized access to sensitive data, such as passwords, credit card details, or personal user information.",
                            "It is recommended to use Prepared Statements (with parameterized queries) instead of string concatenation within the query. Escaping user input/input validation is beneficial. This resource may give more insights. https://portswigger.net/web-security/sql-injection"],

                    [3, "SQL Injection (SQLi) occurs when user controlled input is passed to SQL queries. As a result, an attacker can pass in SQL queries to manipulate the outcome of such queries. A successful SQL injection attack can result in unauthorized access to sensitive data, such as passwords, credit card details, or personal user information.",
                            "It is recommended to use Prepared Statements (with parameterized queries) instead of string concatenation within the query. Escaping user input/input validation is beneficial. This resource may give more insights. https://portswigger.net/web-security/sql-injection"],

                    [4, "Open Ports give attackers a hint to exploit the services. Attackers try to retrieve banner information through the ports and understand what type of service the host is running. Make sure to not open any unnecessary ports.",
                            "It is recommended to close the ports of unused services and use a firewall to filter the ports wherever necessary. This resource may give more insights. https://security.stackexchange.com/a/145781/6137"],
                    
                    [5, "Directory Brute Forcing (also known as directory busting or directory enumeration) is the process of attempting to find hidden or unprotected directories and files on a web server. Itâ€™s often used in web application security testing to identify potential vulnerabilities.",
                            "It is recommended to hide any sensitive directories and files exposed."],

                    [6, "Attackers may gather more information from subdomains relating to the parent domain. Attackers may even find other services from the subdomains and try to learn the architecture of the target. There are even chances for the attacker to find vulnerabilities as the attack surface gets larger with more subdomains discovered.",
                            "It is sometimes wise to block sub-domains like development, staging to the outside world, as it gives more information to the attacker about the tech stack. Complex naming practices also help in reducing the attack surface as attackers find hard to perform subdomain bruteforcing through dictionaries and wordlists."]
            ]

def remediation(vuln, arg1, arg2):
    a,b,c=vul_remed_info(vuln,vuln_resp[vuln][arg1],vuln_resp[vuln][arg2])
    #rs_vul_list.append(vuln_names[vuln][arg1]+"*"+vuln_names[vuln][arg2])
    return a,b,c

def remediation_for_xss(vuln, arg1, arg2):
    xss_solution_list=[]
    vul_remed_info(vuln,vuln_resp[vuln][arg1],vuln_resp[vuln][arg2])
    #rs_vul_list.append(vuln_names[vuln][arg1]+"*"+vuln_names[vuln][arg2])
    xss_solution_list=solution_list
    print(xss_solution_list)
    return xss_solution_list

def remediation_for_sql(vuln, arg1, arg2):
    solution_list.clear()
    sql_solution_list=[]
    vul_remed_info(vuln,vuln_resp[vuln][arg1],vuln_resp[vuln][arg2])
    #rs_vul_list.append(vuln_names[vuln][arg1]+"*"+vuln_names[vuln][arg2])
    sql_solution_list=solution_list
    solution_list.clear()
    return sql_solution_list